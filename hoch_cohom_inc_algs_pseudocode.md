Algorithm HH(X, c)

Purpose:
  Compute the dimensions of the Hochschild cohomology groups dim HH^i associated to the incidence algebra of a finite poset X (reported degree-by-degree until all higher degrees vanish).

Input:
  X      : finite poset
  c      : characteristic (c=0 gives K=Q, otherwise K=GF(c))

Output:
  Prints dim HH^i for successive i, and stops once HH^i = 0 for all larger i.

-----------------------------------------------------------------------

1.  Set the ground field:
      K <-- Q            if c = 0
      K <-- F_c          if c ≠ 0


2. Initialize degree-1 data:
	- Set G as the extended poset of X.
	- Set x* and y* as the minimal and maximal elements of G, respectively.
	- Set x^+ the set of immediate successors of x* in G.
	- Set "candidates" = list of all elements in G.
	- Set q=1 (degree counter), countHH = 0.
	- Initialize "Domain" with a generic indeterminate x.
	- Initialize iCycles = { ([1], z) : z \in x^+ }.
	- Initialize iminusoneCycles =  [[1,x^*]].
	

3.  Handle trivial initial cases:
      If |iCycles| = 0: print “dim HH^i = 0 for all i” and STOP.
      If |iCycles| = 1: print “dim HH^0 = 1 and dim HH^i = 0 for i>0” and STOP.
      Else increment +1 on q.


4.  While q \neq -1 do:  #iterate while cycles persist for q = 2, 3, 4, ...


    (A) Update Spaces:    
    	- Move current "Domain" to "Codomain".
    	- Generate new "Domain" indeterminates based on current iCycles and degree q.
    		For q=2 set "Domain" = { (x, z) : z \in x^+ }, "Codomain" = {x}.
    		For q>2 set "Domain" = { (w^{q-1}_i, iCycles[i][1]) : i=0,..., length(iCycles) }


	(B) Linear Algebra Setup:
		- Define "SourceSpace" and "RangeSpace" as vector spaces over K with basis "Domain" and "Codomain", respectively.
		- Create a linear map \partial between spaces.
		- Store current "iCycles" as "iminusoneCycles".
		- Reset "iCycles" and "Aux_Ciplus".
		
		
	(C) Local Kernel Calculation for each z in "candidates" ( (Kernel \patial_i)_z )
		- Identify "zSubspace" (elements (w,t) in "Domain" such that t<z). 
		- Define "T" as the kernel of \partial restricted to the subspace generated by "zSubspace".
		- If T is non-trivial, store [T,z] in "Aux_Ciplus".
	
	
	(D) Basis Complement (Finding New i-Cycles)
		# For each entry in "Aux_Ciplus":
			- Collect bases from all lower covers of the current element.
			- Find the Basis Complement (new information not covered by predecessors).
			- If the basis complement is non-trivial, add these new basis vectors to "iCycles".
			
			
	(E) Calculate and Print Dimension:
		- If "iCycles" is empty: print termination message; set q=-1.
		- Else:
			- Count how many elements in "iCycles" correspond to the target element y^* ("countHH").
			- Print dimension of HH^{q-2} (adjusting by +1 if q=2) as "countHH".
			- Increment q and reset "countHH".
			
End Algorithm.